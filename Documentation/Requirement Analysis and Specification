Requirements Analysis & Specification

Introduction
Over the years, there has been a surge in popularity of massively multiplayer online games. One constant feature of these games are the dungeon raiding mechanics they employ. However, players will usually have to play many hours before they are ready for these adventures. With our game, players will be able to form a group and raid dungeons right from the beginning. Furthermore, our game will capitalize on the popularity of several other genres; attracting people who may not usually play MMOs.

Problem Statement 
The video game will allow 3 to 5 players to fight AI controlled monsters in a dungeon-like setting. The game will focus on gameplay over story, providing RPG mechanics to allow the players to imagine their own story.

Subproblems
Within scope:
Playable on Windows OS (7 or newer)
Full multiplayer functionality
Graphical user interface

Beyond scope:
Port to iOS, android, linux, etc.
Single-player campaign (or balance for single-player play).
Stability of unreal engine and software made using unreal engine

Requirements 
The game will:
(Functional) Include multiplayer functionality:
Client\Server Model. 
An in game chat system will not be provided.
An area for people to find other people to play with will not be provided in the game.
Internet connection (56Kbps or faster)
Only 1 user designated as “server”.  All others will be clients to this server
The server (and only the server) will maintain a single copy of the GameMode actor.  
The server will provide each client with a GameState actor
Server will provide clients with current map when they connect 
Successful client connections will receive a temporary PlayerController to replicate
Remote Procedure Call (RPC) will be used to update map and state changes
(Functional) Be represented in a graphical manner.
(Quality) Responsive and well-designed layout
(Functional) Allow the player to interact with the game, such as:
HUD and GUI
Other player characters in the game
Enemy units and other non-player characters
The game world
(Platform) Be able to run on desktop computers running Windows 7 or newer.
Requires no special hardware; uses standard keyboard and mouse setup.
(Functional) Save the state of the game.
(Functional) Allow users to load the saved game.
(Functional) Have an inventory system with an item database.
Each player character will have their own inventory system.
Players will be allowed to trade items.
Players can add items to their inventory from the game world.
Players can drop items from their inventory in the game world.
Players can equip equipable items.
(Functional) A combat system that gives the player options depending on their class.
(Quality) As combat is a major component of dungeon-crawlers, the system should be refined and appealing. 
(Functional) A turn-based movement and combat system.
(Quality) While retaining fast-paced gameplay.
 (Functional) Feature an attribute and skills system.
(Process) Use Unreal Engine’s C++ API and scripting language Blueprint.
(Process) Development environment will be Unreal Editor and Microsoft Visual C++

Risk Assessment
No member on the team has created a full game before.Not only will it be challenging learning how to make a game, but we will also not be able to predict what we will be able to accomplish in the given time.
We will be learning more about game design in the beginning to give reasonable goals.
One member has experience with creating modifications for video games.
The Unreal Engine uses a combination of C++ and Blueprint, the latter being its own scripting language. Some members have little experience with C++ and no members have experience with Blueprint.
One member is well-experienced with C++, and there are plenty of available resources for C++.
Epic Games (creators of Unreal Engine) provide many resources for Blueprint. Furthermore, games in Unreal can be made using mostly C++, if necessary.
Video games change quite frequently during development. Using the waterfall method of software engineering may be much less effective in game design.
By leaving out a concrete story, we are given many options with the game’s development. Furthermore, using a very popular setting (medieval/fantasy) gives us a great deal of available resources.
Video game development have many different roles (artists, storyboard writers, animators, etc) that are not fully present in our team full of programmers. 
Independent (Indie) video game development is a well-supported community on the Internet, with plenty of information, resources, and free assets.

System model:


Use cases:
Name: Attack an enemy non-playable character (NPC)
Actors: The player character (PC) and the NPC.
Goal: To attack the NPC.
Precondition: It must be the player character’s turn, they have not fought this turn yet, and the enemy unit is within range of their attack.
Summary: The user wants to attack an enemy unit. They click “Attack” on the GUI, choose their attack, then click on the enemy unit. If all actions were valid, then the user’s character will attack the NPC. The NPC will be damaged to reflect the attack.
Steps: 
User
System
The user clicks the “Attack” button on their GUI.
The system processes the input and changes the GUI to acknowledge the user input. It then waits for the next user input.
The user clicks on the NPC they wish to attack.
The system validates the target selected by the NPC. It will then check all other preconditions.
The user is notified as to whether the attack was valid or not through the GUI.
The game state changes to reflect the damage performed to the NPC. The user is unable to attack again this turn.
Post-Condition: The health of the enemy is updated and the player character cannot fight again this turn.

Name: Move the player character
Actors: The player character (PC).
Goals: The player character moves from starting location to the target location.
Preconditions: it must be the player character’s turn, they have not moved this turn, and the target space is within movement range.
Summary: The user wants to move their character in the game world. The user clicks “Move” on the GUI, then selects where in the game world they want to move. If the location is valid and the player has moves left, the player will move to that location.
Steps:
User
System
The user clicks the “Move” button on their GUI.
The system processes the input and changes the GUI to acknowledge the user input. It then waits for the next user input.
The user clicks on the space they wish to move to.
The system validates the preconditions.
The user sees the character move to the target location.
The game state will update the new location of the player in the game world.
Postconditions: The player’s move count for this turn is decreased by the number of tiles they moved. If this reaches 0, then the player cannot move again until the next turn.

Name: Pickup an item
Actors: The player character (PC), the item.
Goals: The player character adds the item to their item inventory.
Preconditions: The item must be within reach of the player character, and the player must have space in their item inventory.
Summary: The user wants to pick an item up from the game world and add it to their player’s inventory. The player clicks on the item in the game world. If the player is within reach and there is room in their inventory, the user will be given the option to add it to their inventory.
Steps:
User
System
The user clicks on the item.
The system processes the input and checks the preconditions.
The user agrees to add the item to their inventory.
The system gives the player the option to add the item to their inventory.
The user can now see the item in their player’s inventory.
The game state changes to show the item has been picked up. The player’s inventory is updated to include the item.
Postconditions: The item is no longer on the ground. The player’s inventory space has less room in it.

Design Choices: 
i) Use a well-established game engine, or build backend from scratch.
 
Existing Game Engine (Unreal Engine 4)
+Overall less time spent coding the backend.
+Less risks using an established game engine that is known to work.
+Easier to synchronize different components of the project.
+If we wanted to release this as open source or freeware, using a standard and well-known engine would allow others to easily modify the game.
-Learning how to use the game engine will take time.

Building Our Own
+More control over how the game will function.
-Problems may arise when attempting to synchronize the game engine with other components. 
-Coding other parts of the game might need to wait until the basic mechanics are mapped out.

ii) Choosing to focus on the gameplay rather than the story.

Gameplay-Driven
+As the medieval/fantasy genre is the most popular for RPGs, players should be able to understand the context without a major backstory.
+In dungeon-crawlers and rogue-like, the mechanics of the game are often more important than the story.
-Without a story, flaws in the gameplay or mechanics can be more noticeable (i.e, players may be more forgiving of gameplay flaws if it had a good story). 
	
Story-Driven
+People may be more interested in the game if it had a compelling story.
+Many resources are available for the medieval fantasy genre.
-Less time will be spent on the mechanics.
-A story can limit our options when designing the game.

iii) Turn-based system instead of free-roam system.

Turn-Based
	+Much easier to synchronize multiplayer with a turn-based system.
+Gives players more time to think about their decisions, which is why turn-based mechanics are often used in strategic games.
+Places more emphasis on planning movements and actions with the entire group rather than individual skill.
+It is easier for new players to get into turn-based games, as they have time to think and react.
+Movement in the game can be synthesized with motion in the gameworld (e.g. flowing river, swarms of non-enemies bats, glowing lights).
-Players may get bored or lose excitement if a teammate is taking too long with their turn. It is for this reasons that the game is limited to a maximum of 5 players (exact number may change upon testing) per group.

Free Roam
+The combat and movement system will feel more fluid and immersive.
-Much more time and programming intensive for the movement system and other various animations. 
-Without restricted movements, players can encounter bugs more frequently. With our limited time, we cannot reasonably perform large scale beta testing that is needed to find all possible bugs.
-Balancing will be harder to accomplish if the combat is not limited in some way, which may lead to less skills or attacks being in the game.




